
[https://learn.javascript.ru/async](https://learn.javascript.ru/async) 

```js
let promise = new Promise(function(resolve, reject) {  
	// функция-исполнитель (executor)  
});  
```

- executor запускается автоматически, когда Promise создаётся  
- resolve и reject – это колбэки, которые предоставляет сам JavaScript. Когда executor получает результат, вызывается одна из них:  
	- resolve(value) — если работа завершилась успешно, с результатом value.  
	- reject(error) — если произошла ошибка, error – объект ошибки.  
  
У объекта promise, возвращаемого конструктором `new Promise`, есть внутренние свойства:  

- state («состояние») :  
	- вначале "pending" («ожидание»),  
	- потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.  
- result («результат»)  
	- вначале undefined,  
	- далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).  

```js
promise.then(  
	function(result) { /* обработает успешное выполнение */ },  
	function(error) { /* обработает ошибку */ }  
);  
```

- `promise.then` тоже возвращает промис, так что мы можем вызвать на нём следующий `.then`
- Технически возможно добавить много обработчиков `.then` к единственному промису (не цепочкой). Но т.к. это не цепочка, они не передают друг другу результаты своего выполнения, а действуют независимо.  
- Обработчик метода `then()` может отработать ошибку `"throw new Error()"` только, если она передана в колбек resolve/reject  
  
#### Обработчик catch:

Вызов `.catch(f)` – это сокращённый, «укороченный» вариант `.then(null, f)`.  

НО `promise.then(f1).catch(f2);` и `promise .then(f1, f2)` не эквивалентны  

Разница в том, что если ошибка произойдёт в `f1`, то она будет обработана в `.catch` в первом примере, но не во втором. Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после `f1`.  

Другими словами, `.then` передаёт результат ИЛИ ошибку следующему блоку `.then/catch`. Так как в первом примере в цепочке далее имеется блок `catch`, а во втором – нет, то ошибка в нём останется необработанной.  

- перехватывает все виды ошибок в промисах: будь то вызов `reject()` или ошибка, брошенная в обработчике при помощи throw  
- Необходимо размещать `.catch` там, где мы хотим обработать ошибки и знаем, как это сделать. Можно использовть несколько catch в цепочке после соответствующих `then`  
- следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».  

#### Обработчик finally:   

Вызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что `f` выполнится в любом случае, когда промис завершится: успешно или с ошибкой.  

- «пропускает» результат или ошибку дальше, к последующим обработчикам.  
- не имеет аргументов, поэтому не получает результат предыдущего обработчика  
- не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.  

```js
promise  
	.finally(() => остановить индикатор загрузки)  
	.then(result => показать результат, err => показать ошибку)
```

#### Пример

```js
Promise.resolve(10) 
	.then(e => console.log(e)) // 10 
	.then(e => Promise.resolve(e)) 
	.then(console.log) //undefined, т.к. вторая строка ничего не вернет в 3 
	.then(e => { 
		if (!e) { 
			throw 'Error caught'; 
		}
	}) 
	.catch(e => { 
		console.log(e); // error from previous
		return new Error('New error');
	}) 
	.then(e => { 
		console.log(e.message); // 'Error caught'
	}) 
	.catch(e => { 
		console.log(e.message); // не выполнится
	});
```


#### Выполнение асинхронных функций

**Promise.all** 

- ждет, пока выполнятся все запросы, потом выводит их значения в массиве.  
- Если какой-то из них отвалился - валится всё. В случае ошибки, остальные результаты игнорируются  
- Обычно принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».  
  
**Promise.allSettled** 

- всегда ждёт завершения всех промисов. 
- в массиве результатов будет  
	- `{status:"fulfilled", value:результат}` для успешных завершений,  
	- `{status:"rejected", reason:ошибка}` для ошибок.  
  
**Promise.race** 

- очень похож на Promise.all, но ждёт только первый выполненный промис, из которого берёт результат (или ошибку).  
  
**Promise.any** 

- очень похож на Promise.race, но ждёт только первый успешно выполненный промис, из которого берёт результат. 
- если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью `AggregateError` – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве errors.

#### Отличие от observable

- выполняется 1 раз  
- не может быть отменен (без хаков)  
- выполняется сразу, как только он определен (не дожидаясь then), в отличие от обзервабла, который выполняется после подписки