При передаче методов объекта в качестве колбэков, например для setTimeout, возникает известная проблема – потеря `this`.  

```js
setTimeout(user.sayHi, 1000);  
```

Это произошло потому, что setTimeout получил функцию `sayHi` отдельно от объекта `user` (именно здесь функция и потеряла контекст)  

Метод setTimeout в браузере имеет особенность: он устанавливает `this=window` для вызова функции. Таким образом, для `this.firstName` он пытается получить `window.firstName`, которого не существует. В других подобных случаях `this` обычно просто становится `undefined`.  
  
#### Решения:  

1. Cделать функцию-обёртку  
```js
setTimeout(function() {  
	user.sayHi(); // Привет, Вася!  
}, 1000);  
```

Теперь код работает корректно, так как объект `user` достаётся из замыкания, а затем вызывается его метод `sayHi`.  

```js
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!  
```

  
2. Привязать контекст с помощью `bind`

```js
func.bind(context, [arg1], [arg2], ...);  
```

Контекст связанной функции жёстко фиксирован. Изменить однажды привязанный контекст уже нельзя.

#### Bind

Результатом вызова `func.bind(context)` является особый «экзотический объект» (термин взят из спецификации), который вызывается как функция и прозрачно передаёт вызов в `func`, при этом устанавливая `this=context`.  

- позволяет нам выставить значение this для метода  
- c его помощью мы можем каррировать функцию  

#### Call & apply

- псевдомассив - [https://habr.com/ru/articles/336136/](https://habr.com/ru/articles/336136/) 
- call \/ apply - [https://learn.javascript.ru/call-apply-decorators](https://learn.javascript.ru/call-apply-decorators)

  
С их помощью мы можем заимствовать функции и выставлять значение `this` в вызове функции.  

Более того, функция `apply()` в буквальном смысле позволяет нам выполнять функцию в массиве параметров, как-будто каждый параметр передаётся функции индивидуально  
  
Методы `apply()` и `call()` практически идентичны при работе с выставлением значения `this`, за исключением того, что вы передаёте параметры функции в `apply()` как массив (или псевдомассив), в то время, как в `call()`, параметры передаются в индивидуальном порядке (списком аргументов)

```js
func.call(context, …args)  // передаёт массив как список с оператором расширения 
func.apply(context, args); // тот же эффект

func(1, 2, 3);  
func.call(obj, 1, 2, 3)  
func.apply(obj, [1, 2, 3])  
```

  Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы. 
  
  Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator - возвращает текущее значение и метод next, который в свою очередь возващает {value, done} 
  
  Что у них общего? И итерируемые объекты, и псевдомассивы – это обычно не массивы, у них нет методов push, pop
