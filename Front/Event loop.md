Браузерные потоки [https://www.youtube.com/watch?v=InDkFI_LwGM](https://www.youtube.com/watch?v=InDkFI_LwGM) 
Асинхронность и event loop (IШРИ 2022) [https://www.youtube.com/watch?v=5dvqd45j_XM&list=PLKaafC45L_SQqca7_ClyPWTl-EXnEt0lB&index=2](https://www.youtube.com/watch?v=5dvqd45j_XM&list=PLKaafC45L_SQqca7_ClyPWTl-EXnEt0lB&index=2) 

[https://habr.com/ru/articles/681882/](https://habr.com/ru/articles/681882/)  
[https://habr.com/ru/articles/517594/](https://habr.com/ru/articles/517594/)  
[https://habr.com/ru/articles/680846/](https://habr.com/ru/articles/680846/) 

- У каждой вкладки есть свой изолированный и независимый event loop
- Так же он есть у каждого окна, фрейма, воркера
- Есть возможность общения через механизм `postMessage`

### Порядок: 

1. функции добавляются в стек вызовов + выделяется память в heap. Если в в процессе выполнения функции мы встречаем внутреннюю функцию - она добавляется в верх стека вызовов. 
2. при прохождении стека вызовов заполняются очереди событий (макротасков м микротасков) 
3. выполняется стек вызовов начиная с самой старой таски. Все таски выполняются постепенно, примерно каждые 16.6ms пробуем уйти на новый виток event loop'a 
4. после берем очередь микротасок и выполняем их ВСЕ 
5. после этого выполняем ОДНУ макротаску 
6. после этого обновляется интерфейс - render queue (layout \ paint \ composite) 
	- перед этим выполняется коллбек requestAnimationFrame
7. возвращаетмся в п.1 
	- tick - проход от начала и до конца в стеке вызовов. если выполнение кусочка кода занимает не более 16.6ms, тогда мы получаем 60fps (1000 ms / 60) 

### Микротаски

Состоят из коллбеков промисов и observer api

Как только добавляет коллбек, тело коллбека будет добавлено в очередь микротасок

Так же есть функция `queueMicrotask` - браузерное api

```js
Promise.resolve.then(microTask)

(async() => {microTask})()

new MutationObserver(microTask).observe(...)

queueMicrotask(microtask)
```

### Макротаски

Состоят из  эвентов, таймаутов и браузерных апи 

> Не блокируют основной поток JS 


**setTimeout** 
- добавляет событие в очередь через N ms
- гарантирует 100 ms между событиями

**setIntenval**
- добавляет события в очередь каждые N ms
- НЕ НАДЕЖНЫЙ - может пропускать события или запускать несколько раз подряд

**Реальная частота срабатываний может сильно отличаться**

- setTimeout все равно ждет N ms, даже при `setTimeout(fn, 0)`
- В неактивной вкладке частота срабатывания гораздо реже
- `postMessage` - добавит событие в очередь сразу и немедленно. Событие происходит без задержек и быстрее, чем `setTimeout(fn, 0)`

- setImmediate - поставит задачу в очередь немедленно
	- отсутствует в стандарте
	- есть в NodeJS
- В NodeJS есть`process.nextTick` - гарантирует, что мы добавим данную задачу в след tick, минуя очереди

### TODO: RenderQueue 

// Todo

### requestAnimationFrame 
[https://habr.com/ru/companies/timeweb/articles/587908/](https://habr.com/ru/companies/timeweb/articles/587908/)

метод браузера, который планирует запуск анимации (кэллбек) перед отрисовкой след кадра в очереди событий (перед renderQueue)  
  
- он вызывается не чаще и не реже, чем браузер вычисляет макет (правильная частота)  
- он вызывается перед формированием макета (правильное время)  
  
### requestIdleCallback 

позволяет выполнять низкоприоритетные операции в период простоя браузера (отсюда idle) внутри фрейма (обычно, это происходит после вычисления браузером макета и его перерисовки, когда осталось какое-то время перед синхронизацией).  
  
Максимальная продолжительность времени, формально предоставляемая rIC для выполнения задачи, составляет 50 мс. Фактически же в нашем распоряжении имеется всего 0.5-10 мс  

Изменять DOM внутри этого callback нельзя по той причине, что requestIdleCallback может сработать в любой момент времени

### Управление памятью в JS 

[https://habr.com/ru/companies/skillbox/articles/554018/](https://habr.com/ru/companies/skillbox/articles/554018/) 

Стек = статическая память  
- хранит переменные (примитивы - строки, числа, boolean и тп) 
Куча = динамическая память 
- хранит функции и объекты  
  
Что касается стека, то на него указывают все переменные. 
Если же значение не является примитивным, в стеке содержится ссылка на объект из кучи.